using System;
using System.Collections.Generic;
using System.Linq;
using Microsoft.Xna.Framework;
using Microsoft.Xna.Framework.Audio;
using Microsoft.Xna.Framework.Content;
using Microsoft.Xna.Framework.Graphics;
using Microsoft.Xna.Framework.Input;
using Microsoft.Xna.Framework.Media;
/*
formula references:
public float fade_sine_wave_smooth(float duration, float min, float max, sinewave point = sinewave.zero) // sine wave function for interpolation in Engine class
Object movement equations:
v = vo + at
d = vo*t + 1/2at^2
vf^2 – vo^2 = 2ad
 */

namespace EditorEngine
{
    /// <summary>
    /// Particle types
    /// </summary>
    public enum particle_type { unknown, raindrop, star, square, hollow_square, triangle, x, circle };
    /*
     * Info:
     * Particle trajectory type - straight line, chaotic, fall, rise, weightlessness, ballistic trajectory, static, upward fountain, homing missile (set a point if interest or gravity sink). 
     * Each trajectory will have intensity factor variables associated with it which will influence the shape of spread or frequency  of direction change. For example, spread_value 
     * for fountain would mean a wider or narrower cone, randomness_value would mean more chaotic direction change for chaotic particles. 
     * Other values can be added if needed when a new type of trajectory is required by the system. trajectory can also be influenced by the collision mechanic. 
     * Particles can flip their direction (bump off other particles).
     */

    /// <summary>
    /// Particle is an active/passive graphic element generated by the particle Emitter and then handled and updated by ParticleEngine. 
    /// A conceptual AnimatedTexture (multi-sprite Texture2D) could be used as a graphics source for each particle.
    /// A concept AnimationManager will updated AnimatedTexture to show a proper sprite frame based of framerate.
    /// </summary>
    public class Particle //struct for fast processing 
    {
// main Particle properties
        private Vector2 particle_origin;                            // where the particle centre is placed in the world (render coordinates are calculated)
        private Rectangle bounds;                                   // for collision detection - calculate based on size. might also signal deletion of the particle if certain flags are set
        private long particle_life;                                 // number of milli-seconds until particle deletion/decay
        private long particle_creation_time;                        // what game millisecond was this particle created on 
        private long last_update_time;
        private float particle_angular_momentum;                    // angular momentum (in radians per s) – if 0 there is no rotation
        private float particle_angle;                               // current/original angle of rotation
        private particle_type _particle_type;                       // archetype: star, circle, etc.
        private trajectory_type trajectory;                         // movement type
        private float acceleration;                                 // acceleration value in px/s^2  
        private float starting_speed;                               // initial speed of the particle 
        private float speed;                                        // initial speed of the particle 
        private float direction_angle;                              // directional angle used to calculate next position
        private int max_distance;                                   // px value for maximum particle travel distance after which it will be destroyed
        private particle_type auto_spawn_particle_type;             // this is the particle which will be spawned by this original particle based on timing value
        private int auto_spawn_period;                              // time in ms after which a child particle type is spawned      
// scale settings
        private float current_scale;                                // scale value 0 to 1f
        private Vector2 scale_minmax;                               // scale limits for interpolation
        private int scale_fluc_period;                              // scale fluctuation period in ms
        private bool scale_interpolation_flag;                      // dynamic scale?
// transparency settings
        private float transparency;                                 // default value = 1.0f = full
        private Vector2 transparency_minmax;                        // min-max transparency
        private int transparency_fluc_period;                       // scale fluctuation period in ms
        private bool transparency_interpolation_flag;               // change transparency for this particle?
// light sphere settings		
        private bool light_source_particle;                         // has a light sphere
        private Color base_color_light_sphere;                      // color of the color sphere
        private Color secondary_color_light_sphere;                 // what color does particle light sphere interpolate to?
        private int light_sphere_color_fluc_period;                 // scale fluctuation period in ms
        private bool light_color_interpolation_flag;                // dynamic?
        private Int2 light_sphere_size_minmax;                      // radius in px min and max
        private bool light_sphere_size_interpolation_flag;          // is light interpolation turned on or off
        private int light_sphere_size_fluc_period;                  // scale fluctuation period in ms
// particle color settings – needs a white base sprite for best (true color) tint results
        private bool tint_flag;                                     // indicates if this particle should be tinted or it will use original graphics of it’s own image 
        private Color current_color;
        private Color base_tint;                                    // base tint: in case our particle needs tint effect or if it's white and this is color source.
        private Color? secondary_tint;                              // a second tint color to which the base color can interpolate if needed by color change functionality
        private bool tint_interpolation_flag;                       // if true – Particle engine will have to calculate the current tint and then draw this particle on screen.
        private int color_fluc_period;                              // number of milliseconds for color interpolation full cycle
        private bool delete_signal;                                 // if true - delete immediately

        /// <summary>
        /// initiates all basic particle features, additional functions will be created to allow “turning on” 
        /// parameters such as color change or scale change because each one needs additional parameters and will clutter the basic constructor
        /// </summary>
        /// <param name="ptype">particle shape type</param>
        /// <param name="ttype">trajectory type - movement</param>
        /// <param name="origin">particle position for rendering and calculations</param>
        /// <param name="life">particle duration before deletion</param>
        /// <param name="max_distance">maximum travel distance before deldetion</param>
        /// <param name="ang_momentum">rotational speed</param>
        /// <param name="starting_speed">starting movement speed</param>
        /// <param name="acceleration">particle acceleration value in pixels per second squared</param>
        /// <param name="direction_angle">direction of movement</param>
        public Particle(particle_type ptype, trajectory_type ttype, Vector2 origin, int life, int max_distance, float ang_momentum, float starting_speed, float acceleration, float direction_angle)
        {
            particle_origin = origin;
            bounds = Rectangle.Empty;                                           //calculate this like x,y, width,height
            particle_life = life;
            this.max_distance = max_distance;
            particle_creation_time = Engine.get_current_game_millisecond();
            last_update_time = particle_creation_time;
            particle_angular_momentum = ang_momentum;
            particle_angle = 0f;
            this._particle_type = ptype;                                        
            this.trajectory = ttype; 
            this.acceleration = acceleration;                                   // acceleration value in px/s^2 
            this.starting_speed = starting_speed;                               // initial speed of the particle in px/s has to be float but is truncated to int when object is rendered
            this.speed = starting_speed;
            this.direction_angle = direction_angle;
            current_scale = 1.0f;
            scale_minmax = Vector2.One;                                         // scale limits for interpolation
            scale_fluc_period = 0;                                              // scale fluctuation period in ms
            scale_interpolation_flag = false;                                   // dynamic scale?
            transparency = 1.0f;
            transparency_minmax = Vector2.One;                                  // min-max transparency
            transparency_fluc_period = 0;                                       // scale fluctuation period in ms
            transparency_interpolation_flag = false;                            // change transparency for this particle?
            light_source_particle = false;                                      // has a light sphere
            base_color_light_sphere = Color.White;
            secondary_color_light_sphere = Color.White;                         // what color does particle light sphere interpolate to?
            light_sphere_color_fluc_period = 0;                                 // color fluctuation period in ms
            light_color_interpolation_flag = false;                             // dynamic light color? enables gradient of 2 colors
            light_sphere_size_minmax = new Int2(0, 0);                          // light radius in px min and max
            light_sphere_size_interpolation_flag = false;
            light_sphere_size_fluc_period = 0;                                  // scale fluctuation period in ms
            tint_flag = false;                                                  // tinted or use original graphics
            current_color = Color.White;
            base_tint = Color.White;                                            // base tint: in case our particle needs tint effect or if it's white and this is color source.
            secondary_tint = null;                                              // a second tint color to which the base color can interpolate
            tint_interpolation_flag = false;
            color_fluc_period = 0;
            delete_signal = false;
        }

        /// <summary>
        /// Changes scale of the particle based on ms period
        /// </summary>
        /// <param name="min_scale">minimum scale</param>
        /// <param name="max_scale">maximum scale</param>
        /// <param name="period">period of interpolation between minimum and maximum scale, sine wave</param>
        public void enable_dynamic_scale(float min_scale, float max_scale, int period)
        {
            scale_interpolation_flag = true;
            scale_minmax = new Vector2(min_scale, max_scale);
            scale_fluc_period = period; // in ms
        }
        /// <summary>
        /// Get particle type
        /// </summary>
        /// <returns>Shape of the particle as defined in the enum</returns>
        public particle_type get_particle_type()
        {
            return _particle_type;
        }
        /// <summary>
        /// Get particle name
        /// </summary>
        /// <returns>string name of the particle</returns>
        public string get_name()
        {
            return _particle_type.ToString();
        }
        /// <summary>
        /// turn the dynamic scale off
        /// </summary>
        public void disable_dynamic_scale()
        {
            scale_interpolation_flag = false;
        }
        /// <summary>
        /// Order particle deletion
        /// </summary>
        public void set_delete_signal()
        {
            delete_signal = true;
        }
        /// <summary>
        /// Color of the particle. If interpolation is on the color can be anything between the base and secondary colors.
        /// </summary>
        /// <returns>Color object</returns>
        public Color get_color()
        {
            if (tint_interpolation_flag && secondary_tint != null)
            {
                // using the sine wave loop - create a very smooth color interpolaton
                return Color.Lerp(base_tint, (Color)secondary_tint, Engine.fade_sine_wave_smooth(color_fluc_period, 0f, 1f));
            }

            return base_tint;
        }
        /// <summary>
        /// Secondary color 
        /// </summary>
        /// <returns>Either a color object or null if it doesn't exist</returns>
        public Color? get_secondary_color()
        {
            return secondary_tint;
        }
        /// <summary>
        /// Set base color
        /// </summary>
        /// <param name="val">Color value</param>
        public void set_color(Color val)
        {
            base_tint = val;
        }
        /// <summary>
        /// Check if the delete signal is on
        /// </summary>
        /// <returns>true or false</returns>
        public bool get_delete_signal()
        {
            return delete_signal;
        }
        /// <summary>
        /// Get the last update millisecond
        /// </summary>
        /// <returns>ms value</returns>
        public long get_last_update()
        {
            return last_update_time;
        }
        /// <summary>
        /// Refreshes the last udpate ms with current value 
        /// </summary>
        public void refresh_last_update()
        {
            last_update_time = Engine.get_current_game_millisecond();
        }
        /// <summary>
        /// Enable transparency pulsing
        /// </summary>
        /// <param name="t_min">minimum value</param>
        /// <param name="t_max">maximum value</param>
        /// <param name="period">fluctuation period in milliseconds</param>
        public void enable_dynamic_transparency(float t_min, float t_max, int period)
        {
            transparency_interpolation_flag = true;
            transparency_minmax = new Vector2(t_min, t_max);
            transparency_fluc_period = period;
        }
        /// <summary>
        /// Disable the dynamic transparency functionality for this particle.
        /// </summary>
        public void disable_dynamic_transparency()
        {
            transparency_interpolation_flag = false;
        }
        // future ideas for light spheres
        /*public void enable_light_scale_features(int min_radius, int max_radius, int period)
        {
            this.light_source_particle = true; // faster to assign than to check if it’s already true
            light_sphere_size_interpolation_flag = true;
            light_sphere_size_minmax = new Int2(min_radius, max_radius);
            light_sphere_size_fluc_period = period;
        }
        public void enable_light_color_features(Color base_light, Color secondary_light, int period)
        {
            this.light_source_particle = true; // faster to assign than to check if it’s already true
            light_color_interpolation_flag = true;
            base_color_light_sphere = base_light;
            secondary_color_light_sphere = secondary_light;
            light_sphere_color_fluc_period = period;
        }
        public void disable_light_features(bool has_light_sphere, bool has_dynamic_light_sphere, bool has_dynamic_light_color)
        {
            this.light_source_particle = has_light_sphere;
            light_color_interpolation_flag = has_dynamic_light_color;
            light_sphere_size_interpolation_flag = has_dynamic_light_sphere;
        }*/

        /// <summary>
        /// this can turn on tint color for particles and optional tint color change parameters
        /// NOTE: for multiple default parameters – use myfunc(a, c:5) type of call to only use parameters needed (named parameters)
        /// example call: f(blue); or f(blue,green,500); no need to specify flag value explicitly
        /// </summary>
        /// <param name="base_color">base color</param>
        /// <param name="secondary_color">secondary color to interpolate to</param>
        /// <param name="period">time period in ms</param>
        public void enable_color_features(Color base_color, Color? secondary_color = null, int period = 0)
        {
            tint_flag = true;
            base_tint = base_color;
            secondary_tint = secondary_color ?? base_color; // if secondary color is null - assign the same base color to it to eliminate color switching
            
            if (secondary_color != null)
                tint_interpolation_flag = true;

            color_fluc_period = period;
        }
        /// <summary>
        /// Turn color interpolation off
        /// </summary>
        /// <param name="tint_color">true or false</param>
        /// <param name="change_color">true or false</param>
        public void disable_color_features(bool tint_color, bool change_color)
        {
            tint_flag = tint_color;
            tint_interpolation_flag = change_color;
        }
        /// <summary>
        /// Add a vector position to current position (does not replace the position)
        /// </summary>
        /// <param name="v">adjustment vector</param>
        public void adjust_position(Vector2 v)
        {
            particle_origin += v;
        }
        /// <summary>
        /// add a horizontal/vertical component only to the position
        /// </summary>
        /// <param name="v">adjustment vector</param>
        /// <param name="horizontal">horizontal portion or the vertical portion of the position vector</param>
        public void adjust_position(float v, bool horizontal)
        {
            if(horizontal)
                particle_origin.X += v;
            else
                particle_origin.Y += v;
        }
        /// <summary>
        /// Get current particle speed
        /// </summary>
        /// <returns>float speed value in px per second</returns>
        public float get_speed()
        {
            return starting_speed + Engine.convert_rate(acceleration,Engine.get_current_game_millisecond() - particle_creation_time); 
        }
        /// <summary>
        /// Get vector position
        /// </summary>
        /// <returns>Vector2 position in pixels</returns>
        public Vector2 get_position()
        {
            return particle_origin;
        }
        /// <summary>
        /// Get the particle creation time as an ms value since program start
        /// </summary>
        /// <returns>creation ms</returns>
        public long get_creation_time()
        {
            return particle_creation_time;
        }
        /// <summary>
        /// Get particle lifetime
        /// </summary>
        /// <returns>ms value</returns>
        public long get_particle_life()
        {
            return particle_life;
        }
        /// <summary>
        /// Check the dynamic scale flag
        /// </summary>
        /// <returns>true or false</returns>
        public bool has_dynamic_scale()
        {
            return scale_interpolation_flag;
        }
        /// <summary>
        /// Get the current scale flag
        /// </summary>
        /// <returns>float value</returns>
        public float get_current_scale()
        {
            return current_scale;
        }
        /// <summary>
        /// Set a new scale value
        /// </summary>
        /// <param name="value">float value in any range</param>
        public void set_current_scale(float value)
        {
            current_scale = value;
        }
        /// <summary>
        /// Get the scale fluctuation period value
        /// </summary>
        /// <returns>ms value</returns>
        public int get_scale_fluc_period()
        {
            return scale_fluc_period;
        }
        /// <summary>
        /// Min/max scale value
        /// </summary>
        /// <returns>min and max value in one Vector2</returns>
        public Vector2 get_scale_minmax()
        {
            return scale_minmax;
        }
        /// <summary>
        /// Check dynamic transparency flag
        /// </summary>
        /// <returns>true or false</returns>
        public bool has_dynamic_transparency()
        {
            return transparency_interpolation_flag;
        }       
        /// <summary>
        /// Check the dynamic color tint flag value
        /// </summary>
        /// <returns>true or false</returns>
        public bool has_dynamic_tint()
        {
            return tint_interpolation_flag;
        }
        /// <summary>
        /// Get the trajectory type
        /// </summary>
        /// <returns>trajectory_type value, e.g. fall,rise.</returns>
        public trajectory_type get_trajectory_type()
        {
            return trajectory;
        }
        /// <summary>
        /// Add rotational speed to current particle angle
        /// </summary>
        public void rotate_particle()
        {
            particle_angle += (particle_angular_momentum / 1000) * 16.67f; // testing rotation scaled to 60 fps 
        }
        /// <summary>
        /// Get particle angle (current)
        /// </summary>
        /// <returns>float value of the angle in radians</returns>
        public float get_particle_angle()
        {
            return particle_angle;
        }
    }

        
    /// <summary>
    /// Use this class to generate test particles
    /// creates particles on mouse pointer
    /// Implements the IParticleCreating interface that ensures proper particle creation functions are created.
    /// </summary>
    public class ParticleTester: IParticleCreating
    {
        /// <summary>
        /// List of Emitter objects
        /// </summary>
        public List<Emitter> emitters
        {
            get
            {
                return _emitters;
            }
            set
            {
                _emitters = value;
            }
        }
        private List<Emitter> _emitters;

        public ParticleTester()
        {
            _emitters = new List<Emitter>();
        }
// interface functions
        /// <summary>
        /// Get a list of particle emitters
        /// </summary>
        /// <returns>List of Emitter objects</returns>
        public List<Emitter> get_particle_emitters()
        {
            return emitters;
        }
        /// <summary>
        /// Add new Emitter to the list
        /// </summary>
        /// <param name="e">Emitter object</param>
        public void Add(Emitter e)
        {
            emitters.Add(e);
        }
        /// <summary>
        /// Update mitter position for moving objects containing particle generators
        /// </summary>
        /// <param name="position_adjustment">Vector2  - position adjustment</param>
        public void update_emitter_position(Vector2 position_adjustment)
        {
            foreach(Emitter e in emitters)
            {
                e.set_position(position_adjustment);
            }
        }
        /// <summary>
        /// Generate a signal that turnes particle creation on
        /// </summary>
        public void generate_particle_signal()
        {
            foreach (Emitter e in _emitters)
            {
                e.generate_particle_signal();
            }
        }
        /// <summary>
        /// Turn particle creation off
        /// </summary>
        public void disable_particle_signal()
        {
            foreach (Emitter e in _emitters)
            {
                e.remove_particle_signal();
            }
        }
        /// <summary>
        /// Disable the color interpolation sequence
        /// </summary>
        public void disable_color_interpolation()
        {
            foreach (Emitter e in _emitters)
            {
                e.enable_color_interpolation(Color.White,false);
            }
        }
        /// <summary>
        /// Turn color interpolation on
        /// </summary>
        /// <param name="clr">Color - secondary tint</param>
        public void enable_color_interpolation(Color clr)
        {
            foreach (Emitter e in _emitters)
            {
                e.enable_color_interpolation(clr,true);
            }
        }
    }
}
