using System;
using System.Collections.Generic;
using System.Linq;
using Microsoft.Xna.Framework;
using Microsoft.Xna.Framework.Audio;
using Microsoft.Xna.Framework.Content;
//using Microsoft.Xna.Framework.GamerServices;
using Microsoft.Xna.Framework.Graphics;
using Microsoft.Xna.Framework.Input;
using Microsoft.Xna.Framework.Media;
/*
references:
public float fade_sine_wave_smooth(float duration, float min, float max, sinewave point = sinewave.zero) // sine wave function for interpolation in Engine class
Object movement equations:
v = vo + at
d = vo*t + 1/2at^2
vf^2 – vo^2 = 2ad*/

namespace beta_windows
{
    public enum trajectory_type { laser_line, chaotic, fall, rise, weightlessness, ballistic_curve, static_, upward_fountain, homing_missile };
    /*Particle Struct
    ---------------------------------------------------------------------------------------------------------------------------------------------------
    Particle is an active/passive graphic element generated by the particle Emitter and then handled and updated by ParticleEngine. 
    AnimatedTexture will be used as a graphics source for each particle.
    AnimationManager will updated AnimatedTexture to show a proper sprite frame based of framerate.
    */
    /*Particle trajectory type - straight line, chaotic, fall, rise, weightlessness, ballistic trajectory, static, upward fountain, homing missile (set a point if interest or gravity sink). Each trajectory will have intensity factor variables associated with it which will influence the shape of spread or frequency  of direction change. For example, spread_value for fountain would mean a wider or narrower cone, randomness_value would mean more chaotic direction change for chaotic particles. Other values can be added if needed when a new type of trajectory is required by the system. trajectory can also be influenced by the collision mechanic. Particles can flip their direction (bump off other particles).*/
    // This can also be used to represent light source singularity - also scale change can be used to simulate pulsing light spheres
    public struct Particle //struct for fast processing 
    {// general settings
        //private AnimatedTexture particle_sprite;  // get from AnimationEngine based on particle_type value. Get a list of all particle types currently active, then for each unique one do a rendering loop to eliminate texture switching
        private Vector2 particle_size; // size of the sprite in px, e.g. 100x50px
        private Vector2 particle_origin; // where the particle centre is defined, render coordinates are calculated
        private Rectangle bounds; // for collision detection - calculate based on size. might also signal deletion of the particle if certain flags are set
        private long particle_life;                     // number of milli-seconds until particle deletion/decay
        private long particle_creation_time; // what game millisecond was this particle created on 
        private float particle_angular_momentum; // angular momentum (in radians per s) – if 0 there is no rotation
        private float particle_angle;            // current/original angle of rotation
        private particle_type _particle_type; // archetype: star,circle, cube.
        private trajectory_type trajectory; // movement type
        private float acceleration; // acceleration value in px/s^2  
        private float starting_speed; // initial speed of the particle 
        private float direction_angle; // directional angle used to calculate next position
        private int max_distance; // px value for maximum particle travel distance after which it will be destroyed
        // advanced functionality
        private particle_type auto_spawn_particle_type; // this is the particle which will be spawned by this original particle based on timing value
        private int auto_spawn_period; // time in ms after which a child particle type is spawned
        // scale settings
        private float current_scale;
        private Vector2 scale_minmax; // scale limits for interpolation
        private int scale_fluc_period; // scale fluctuation period in ms
        private bool scale_interpolation_flag; // dynamic scale?
        // transparency settings
        private float transparency; // default value = 1.0f
        private Vector2 transparency_minmax; // min-max transparency
        private int transparency_fluc_period; // scale fluctuation period in ms
        private bool transparency_interpolation_flag; // change transparency for this particle?
        // light sphere settings		
        private bool light_source_particle; // has a light sphere
        private Color base_color_light_sphere;
        private Color secondary_color_light_sphere;// what color does particle light sphere interpolate to?
        private int light_sphere_color_fluc_period; // scale fluctuation period in ms
        private bool light_color_interpolation_flag; // dynamic?
        private Int2 light_sphere_size_minmax; // radius in px min and max
        private bool light_sphere_size_interpolation_flag;
        private int light_sphere_size_fluc_period; // scale fluctuation period in ms
        // particle color settings – needs a white base sprite for best results
        private bool tint_flag; // indicates if this particle should be tinted or it will use original graphics of it’s own image 
        private Color base_tint; // base tint: in case our particle needs tint effect or if it's white and this is color source.
        private Color secondary_tint; // a second tint color to which the base color can interpolate if needed by color change functionality
        private bool tint_interpolation_flag; // if true – Particle engine will have to calculate the current tint and then draw this particle on screen.
        private int color_fluc_period;

        // constructor – initiates all basic particle features, additional functions will be created to allow “turning on” parameters such as color change or scale change because each one needs additional parameters and will clutter the basic constructor
        public Particle(particle_type ptype, trajectory_type ttype, Vector2 size, Vector2 origin, int life, int max_distance, int current_time, float ang_momentum, float starting_speed, float acceleration, float direction_angle, particle_type child_particle, int child_spawn_period)
        {
            particle_size = size;
            particle_origin = origin;
            bounds = Rectangle.Empty; //calculate this like x,y, width,height
            particle_life = life;
            this.max_distance = max_distance;
            particle_creation_time = current_time;
            particle_angular_momentum = ang_momentum;
            particle_angle = 0f;
            this._particle_type = ptype; // archetype: star,circle, cube.
            this.trajectory = ttype; // movement type
            this.acceleration = acceleration; // acceleration value in px/s^2 
            this.starting_speed = starting_speed; // initial speed of the particle in px/s has to be float but is truncated to int when object is rendered	
            this.direction_angle = direction_angle;
            auto_spawn_particle_type = child_particle;
            auto_spawn_period = child_spawn_period;
            // additional parameters
            current_scale = 1.0f;
            scale_minmax = Vector2.One; // scale limits for interpolation
            scale_fluc_period = 0; // scale fluctuation period in ms
            scale_interpolation_flag = false; // dynamic scale?

            transparency = 1.0f;
            transparency_minmax = Vector2.One; // min-max transparency
            transparency_fluc_period = 0; // scale fluctuation period in ms
            transparency_interpolation_flag = false; // change transparency for this particle?

            light_source_particle = false; // has a light sphere
            base_color_light_sphere = Color.White;
            secondary_color_light_sphere = Color.White;// what color does particle light sphere interpolate to?
            light_sphere_color_fluc_period = 0; // color fluctuation period in ms
            light_color_interpolation_flag = false; // dynamic light color? enables gradient of 2 colors
            light_sphere_size_minmax = new Int2(0, 0); // light radius in px min and max
            light_sphere_size_interpolation_flag = false;
            light_sphere_size_fluc_period = 0; // scale fluctuation period in ms

            tint_flag = false; // tinted or use original graphics
            base_tint = Color.White; // base tint: in case our particle needs tint effect or if it's white and this is color source.
            secondary_tint = Color.White; // a second tint color to which the base color can interpolate
            tint_interpolation_flag = false;
            color_fluc_period = 0;
        }

        // Particle appearance changing functions
        public void enable_dynamic_scale(float min_scale, float max_scale, int period)
        {
            scale_interpolation_flag = true;
            scale_minmax = new Vector2(min_scale, max_scale);
            scale_fluc_period = period; // in ms
        }

        public void disable_dynamic_scale()
        {
            scale_interpolation_flag = false;
        }

        public void enable_dynamic_transparency(float t_min, float t_max, int period)
        {
            transparency_interpolation_flag = true;
            transparency_minmax = new Vector2(t_min, t_max);
            transparency_fluc_period = period;
        }

        public void disable_dynamic_transparency()
        {
            transparency_interpolation_flag = false;
        }

        public void enable_light_scale_features(int min_radius, int max_radius, int period)
        {
            this.light_source_particle = true; // faster to assign than to check if it’s already true
            light_sphere_size_interpolation_flag = true;
            light_sphere_size_minmax = new Int2(min_radius, max_radius);
            light_sphere_size_fluc_period = period;
        }

        public void enable_light_color_features(Color base_light, Color secondary_light, int period)
        {
            this.light_source_particle = true; // faster to assign than to check if it’s already true
            light_color_interpolation_flag = true;
            base_color_light_sphere = base_light;
            secondary_color_light_sphere = secondary_light;
            light_sphere_color_fluc_period = period;
        }

        public void disable_light_features(bool has_light_sphere, bool has_dynamic_light_sphere, bool has_dynamic_light_color)
        {
            this.light_source_particle = has_light_sphere;
            light_color_interpolation_flag = has_dynamic_light_color;
            light_sphere_size_interpolation_flag = has_dynamic_light_sphere;
        }
        // this can turn on tint color for particles and optional tint color change parameters
        // NOTE: for multiple default parameters – use myfunc(a, c:5) type of call to only use parameters needed (named parameters)
        // example call: f(blue); or f(blue,green,500); no need to specify flag value explicitly
        public void enable_color_features(Color base_color, Color? secondary_color = null, int period = 0)
        {
            tint_flag = true;
            base_tint = base_color;
            secondary_tint = secondary_color ?? base_color; // if secondary color is null - assign the same base color to it to eliminate color switching
            if (secondary_color != null)
                tint_interpolation_flag = true;
            color_fluc_period = period;
        }

        public void disable_color_features(bool tint_color, bool change_color)
        {
            tint_flag = tint_color;
            tint_interpolation_flag = change_color;
        }
        // other functions 
        public void draw()
        {
            // need to use standard XNA draw function in main Engine and supply it with appropriate values which are all modified by AnimationEngine.
        }
        public void draw_light_sphere() // separate from draw – must be drawn to light dedicated graphical memory section
        {
            // lift the design from existing PointLight spheres with one change. All spheres will have a default radius of 1024px? which will then be scaled down or up based on light sphere native value and native scale. Example: sphere of radius 300 scaled to 1.2x size will be 360px. 360/1024px ~= 0.351 render scale for a standard texture. Use floats for adequate precision. Doesn’t require extreme precision.
        }

        public Vector2 particle_render_origin()// calculates current rendering coordinates based on origin in particle center 
        {
            Vector2 a = particle_origin;
            Vector2 b = particle_size * current_scale; // apply scale value – standard = 1.0f
            return new Vector2(a.X - (b.X / 2), a.Y - (b.Y / 2));
        }

        public long get_creation_time()
        {
            return particle_creation_time;
        }

        public long get_particle_life()
        {
            return particle_life;
        }

        public bool has_dynamic_scale()
        {
            return scale_interpolation_flag;
        }

        public float get_current_scale()
        {
            return current_scale;
        }

        public void set_current_scale(float value)
        {
            current_scale = value;
        }

        public int get_scale_fluc_period()
        {
            return scale_fluc_period;
        }

        public Vector2 get_scale_minmax()
        {
            return scale_minmax;
        }

        public bool has_dynamic_transparency()
        {
            return transparency_interpolation_flag;
        }

        public bool has_dynamic_light_sphere_size()
        {
            return light_sphere_size_interpolation_flag;
        }

        public bool has_dynamic_light_color()
        {
            return light_color_interpolation_flag;
        }
        public bool has_dynamic_tint()
        {
            return tint_interpolation_flag;
        }

        public trajectory_type get_trajectory_type()
        {
            return trajectory;
        }

        public void rotate_particle()
        {
            particle_angle += (particle_angular_momentum / 1000) * 16.67f; // testing rotation scaled to 60 fps 
        }
    }

    /*Particle Emitter class
    An object that takes care of emitting particles into the game World and setting their initial parameters, however, particle life afterwards is taken over by the main Engine class.
    Emitter should be able to spawn particles from a single point (with are defined by circle radius), or a pattern (such as square)
    */
    public class Emitter
    {
        // concept class for managing particle spawn points
        private Vector2 position; // might change, e.g. bullets of a gun – change position of gun’s muzzle – in this case gun/magic staff object will update the position of where it  needs to shoot projectiles from and emitter’s values will change this way. they can also change based on emitter own trajectory handler 
        private particle_type _particle_type; // sets up corresponding particle variable 
        long creation_time;
        int emitter_duration; // emitters can despawn after a period of time – this is a minimum amount of emitter lifetime in ms, if it’s -1 – emitter is considered eternal
        bool automatic_generation; // if false an event is needed
        private bool random_type; // if true – a random particle type will be emitted every time
        int rate; // number of milliseconds until next particle spawn	
        private trajectory_type trajectory; // movement trajectory assigned to particles
        int number_of_particles_in_burst; // how many particles in 1 burst
        bool random_color_flag; // create a random tint for particle or use particle’s base tint
        int emitter_radius; // area of effect where particle is allowed to spawn, can range from 0px to any number, this will be considered in random number generator when setting Particle’s particle_origin variable. If it’s 0 it will be created at emitter’s origin (defined as a centre point)
        // constructor section
        public Emitter(long current_time, Vector2 pos, particle_type ptype, bool random, int emitter_life_duration, int rate, bool auto, trajectory_type ttype, int number_of_particles_in_burst, bool random_color, int area_radius)
        {
            position = pos;
            this._particle_type = ptype;
            random_type = random;
            emitter_duration = emitter_life_duration;
            this.rate = rate;
            automatic_generation = auto;
            this.trajectory = ttype;
            this.number_of_particles_in_burst = number_of_particles_in_burst;
            random_color_flag = random_color; // assigns a random color instead of a built in color value
            emitter_radius = area_radius;
            creation_time = current_time; // get ms value from Engine and assign as a beginning point 
        }

        //functions
        // generates particle when called, can also be automated with a 'rate' ms between bursts. Particle object can the be added to particles list in ParticleEngine
        public Particle generate_particle()
        {
            Particle temp = new Particle(); // complete a constructor here using proper positioning and 
            return temp;
        }
        // used to check if it’s time to remove this emitter from the list of active emitters in ParticleEngine
        public bool terminated(int current_time)
        {
            if (current_time > creation_time + emitter_duration)
                return true;

            return false;
        }

        public bool has_automatic_generation()
        {
            return automatic_generation;
        }
        // Emitter updater
        public void update()
        {

        }
    }
    /*ParticleEngine class
    This class manages entire particle system. Most overarching functions must go here.
    After Particle has been created by Emitter it will be modified by Particle Engine and it’s movement, rotations and other transformations will be handled here.
    */
    public class ParticleEngine
    {
        private bool additive_blending_flag; // this defines if all particles (draw to their own 
        //private float global gravity; // this value will handle natural dropping of objects, there can be local gravity as well,this variable will have to be stored at World level with zones of low or high gravity specifically defined. World managing object will decide what gravity value should be assigned to an object in question based on their position in the world.
        private List<Particle> p; // define a starting capacity large enough to only allocate memory once and not slow down the system (List.Capacity)
        private List<Emitter> emitters; // source of particles: assigns a starting position, direction, movement trajectory, type of particle generated, scaling behavior, lifetime etc. These object only generate particles, everything else is handled by particle engine update cycle which loops through all particles in the list and based on their trajectory, scale behaviour, direction, rotation each one will change position and orientation.
        // random number generator - use main engine static function when needed

        public ParticleEngine()
        {
            p = new List<Particle>();
        }

        // functions to manage particles
        // first test of the engine involves handling multiple particles with a straight vector trajectories, i.e. x=2px/s, y=1px/s, or given a velocity and an angle of movement
        public void delete_emitter() // and all its particles, or just the emitter but keep particles active
        {
            // remove element from the list when Emitter is no longer needed 
        }

        public void update(Engine e)// Update all dynamic parameters
        {
            // defines the algorithm handling movement, rotation, shape/scale change and lifetime of particle as well as collision detection and signalling events (event such as particle hit a block, a player, an enemy, another particle)

            // iterate all particles
            for (int i = p.Count; i >= 0; i--)
            {
                //p[i]; // a particle object stored in the List. Not a passed by value copy p[i]
                // check existence limits
                if (p[i].get_creation_time() + p[i].get_particle_life() <= e.get_current_game_millisecond())
                {
                    p.RemoveAt(i); //delete particle from the end of the list and move on
                    continue;
                }
                // update particle scale
                if (p[i].has_dynamic_scale())
                {
                    // use an interpolation function from main game engine class to select a value from min/max pair based on current time value
                    // a standard sine oscillation function integrated with current game time value
                    p[i].set_current_scale(e.fade_sine_wave_smooth(p[i].get_scale_fluc_period(), p[i].get_scale_minmax().X, p[i].get_scale_minmax().Y)); // automatically uses current game millisecond
                }
                // update particle transparency
                if (p[i].has_dynamic_transparency())
                {
                    // use an interpolation function from main game engine class to select a value from min/max pair based on current time value
                }
                // update particle light sphere
                if (p[i].has_dynamic_light_sphere_size())
                {
                    // use an interpolation function from main game engine class to select a value from min/max pair based on current time value	
                }
                if (p[i].has_dynamic_light_color())
                {
                    // use an interpolation function from main game engine class to select a value from min/max pair based on current time value
                }
                // update particle color
                if (p[i].has_dynamic_tint())
                {
                    // update particle color using interpolation function between two colors
                }
                // update particle position
                switch (p[i].get_trajectory_type()) // based on pre-defined value calculate new coordinates for this particle
                {// for collision purposes need to know if line between two points (old and new) intersect collision rectangle of any object. Use the geeksforgeeks c++ program example to check intersection between a ballistic line and each of the 4 lines of collision bounding rectangle
                    // update position
                    // check for collision with visible* ground/props and create a collision event?
                    // check for collision with active characters and create a collision event?
                    //* any objects that are on screen. For characters this check is unnecessary
                    // all trajectories so far:straight line laser, chaotic, fall, rise, weightlessness, ballistic trajectory, static, upward fountain, homing missile
                    case trajectory_type.laser_line: // calculate by taking current point, direction angle, 0 value for gravity, speed and acceleration and use in a physics formula
                        // algorithm is designed at the bottom of the file – a simple particle movement in straight line with acceleration value if applicable
                        break;
                    case trajectory_type.chaotic: // take current point, particle speed and acceleration and transfer it in a random direction
                        break;
                    case trajectory_type.fall: // apply local gravity value and push particle down 
                        break;
                    case trajectory_type.rise:// apply 0 gravity and push particle up using speed and acceleration value
                        break;
                    case trajectory_type.weightlessness: // apply sinewave function to float the particle around it’s original point in space for 2 axis x and y. slow movement
                        break;
                    case trajectory_type.ballistic_curve: // apply local gravity value and all other parameters to send particle in a curve
                        break;
                    case trajectory_type.static_: // no position changes particle stays frozen in space
                        break;
                    case trajectory_type.upward_fountain: // similar to straight up rise but with a random narrow angle direction for each particle. this will cause many particles to form a cone of random angle
                        break;
                    case trajectory_type.homing_missile: // based on a target send this particle towards it
                        break;
                    default: // no specific value
                        break;
                }
                // update particle rotation (ez)
                p[i].rotate_particle(); // adds particle's angular momentum to existing particle rotation angle based on timing
            }
        }

        public void create_collision_event() // this is a supporting function that should be called by update any time there is a collision of particle with any World active object such as a ground block. Based on what particle collided with call that object’s function, e.g. receive_bullet_damage() or receive_magic_damage() etc and then delete the particle or let it fly through and live out the rest of particle_life ticks before being cleaned up by managing class. A generic_1 can be set up as an int to capture the amount of damage this particle carries.
        {
            // check for collision between this particles bounding box and any object of interest (that exist in near area)
            // invoke a function on an object collided with and then remove the particle or let it continue 
        }
        public void draw()//every particle is drawn based only on it’s current position, scale, color and rotation variables. Changes to these are handled in an update function.
        {
            //use the standard XNA rendering algorithm
        }

        public void generate_particle(Vector2 position, trajectory_type trajectory, float rotation, bool scale_change) // creates a particle – one time event. Iterate all emitters and generate particles (0 or more)
        {
            foreach (Emitter e in emitters)
            {
                // for each existing emitter – generate a particle automatically if emitter is automatic
                if (e.has_automatic_generation())
                    e.generate_particle();// should use internal e object parameters to spawn a particle 
            }
        }
        // Emitter generator
        public void create_emitter(Engine e, Vector2 pos, particle_type ptype, bool random, int emitter_life_duration, int rate, bool auto, trajectory_type ttype, int number_of_particles_in_burst, bool random_color, int area_radius) // handle particle emitter creation – particle types and standard values for each type are encoded at this point. Afterwards, emitter simply follow the rules. Use an enumerated type to specify the particles needed
        {
            Emitter temp = new Emitter(e.get_current_game_millisecond(), pos, ptype, random, emitter_life_duration, rate, auto, ttype, number_of_particles_in_burst, random_color, area_radius); // call Emitter constructor using parameters supplied by Engine
            emitters.Add(temp);
        }
    }
}
